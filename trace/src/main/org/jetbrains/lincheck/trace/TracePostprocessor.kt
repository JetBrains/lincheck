/*
 * Lincheck
 *
 * Copyright (C) 2019 - 2025 JetBrains s.r.o.
 *
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed
 * with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

package org.jetbrains.lincheck.trace


interface TracePostprocessor {
    fun postprocess(reader: LazyTraceReader, tracePoint: TRMethodCallTracePoint): TRTracePoint
}

object CompressingPostprocessor : TracePostprocessor {

    override fun postprocess(reader: LazyTraceReader, tracePoint: TRMethodCallTracePoint): TRTracePoint {
        return tracePoint
            .compressDefaultPairs(reader)
            .compressAccessPairs(reader)
            .compressSyntheticFieldAccess(reader)
    }

    /**
     * Compresses `fun$default(...)` calls.
     *
     * Kotlin functions with default values are represented as two nested calls in the stack trace.
     *
     * For example:
     *
     * ```
     * A.callMe$default(A#1, 3, null, 2, null) at A.operation(A.kt:23)
     *   A.callMe(3, "Hey") at A.callMe$default(A.kt:27)
     * ```
     *
     * will be collapsed into:
     *
     * ```
     * A.callMe(3, "Hey") at A.operation(A.kt:23)
     * ```
     *
     */
    private fun TRMethodCallTracePoint.compressDefaultPairs(reader: LazyTraceReader): TRMethodCallTracePoint {
        if (events.size != 1) return this
        val singleChild = loadChild(reader, tracePoint = this, 0)
        if (singleChild == null) return this

        if (singleChild !is TRMethodCallTracePoint) return this
        if (!haveSameOwner(className, singleChild.className) || !isDefaultPair(methodName, singleChild.methodName)) return this

        return combineCallNodes(this, singleChild)
    }

    /**
     * Compresses `.access$` calls.
     *
     * The `.access$` methods are generated by the Kotlin compiler to access otherwise inaccessible members
     * (e.g., private) from lambdas, inner classes, etc.
     *
     * For example:
     *
     * ```
     * A.access$callMe() at A.operation(A.kt:N)
     *  A.callMe() at A.access$callMe(A.kt:N)
     * ```
     *
     * will be collapsed into:
     *
     * ```
     * A.callMe() at A.operation(A.kt:N)
     * ```
     *
     */
    private fun TRMethodCallTracePoint.compressAccessPairs(reader: LazyTraceReader): TRMethodCallTracePoint {
        if (events.size != 1) return this
        val singleChild = loadChild(reader, tracePoint = this, 0)
        if (singleChild == null) return this

        if (singleChild !is TRMethodCallTracePoint) return this
        if (!haveSameOwner(className, singleChild.className) || !isAccessPair(methodName, singleChild.methodName)) return this

        return combineCallNodes(this, singleChild)
    }

    /**
     * Compresses synthetic field access methods (`access$get` and `access$set`).
     *
     * These methods are generated by the Kotlin compiler when a lambda or inner class accesses a private field.
     * This function removes the synthetic access method and keeps only the actual field access event.
     *
     * For example:
     *
     * ```
     * A.access$get_field(A#1) at A.operation(A.kt:N)
     *   field ➜ value at A.access$get_field(A.kt:N)
     * ```
     *
     * will be collapsed into:
     *
     * ```
     * field ➜ value at A.operation(A.kt:N)
     * ```
     *
     * This is different from `fun$access`, which is addressed in [compressAccessPairs].
     *
     */
    private fun TRMethodCallTracePoint.compressSyntheticFieldAccess(reader: LazyTraceReader): TRTracePoint {
        if (events.size != 2 && events.size != 3) return this
        if (!isSyntheticFieldAccess(methodName)) return this

        // get and set method versions have different number of children (2 and 3, correspondingly)
        // the correct access node is stored at the last position
        val actualNode = if (isSyntheticGetFieldAccess(methodName)) loadChild(reader, tracePoint = this, 1) ?: return this
                         else loadChild(reader, tracePoint = this, 2) ?: return this

        return actualNode
    }

    private fun loadChild(reader: LazyTraceReader, tracePoint: TRMethodCallTracePoint, childIdx: Int): TRTracePoint? {
        if (childIdx !in 0..tracePoint.events.lastIndex) return null
        return tracePoint.events[childIdx] ?: reader.getChildAndRestorePosition(tracePoint, childIdx)
    }

    private fun combineCallNodes(parent: TRMethodCallTracePoint, child: TRMethodCallTracePoint): TRMethodCallTracePoint {
        val newNode = TRMethodCallTracePoint(
            child.threadId,
            parent.codeLocationId,
            child.methodId,
            child.obj,
            child.parameters,
            child.eventId
        )
        newNode.result = child.result
        newNode.exceptionClassName = child.exceptionClassName
        newNode.replaceChildren(child)
        return newNode
    }
}
