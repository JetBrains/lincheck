/*
 * Lincheck
 *
 * Copyright (C) 2019 - 2025 JetBrains s.r.o.
 *
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed
 * with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

package org.jetbrains.lincheck.trace


interface TracePostprocessor {
    fun postprocess(reader: LazyTraceReader, tracePoint: TRMethodCallTracePoint): TRTracePoint
}

object CompressingPostprocessor : TracePostprocessor {

    override fun postprocess(reader: LazyTraceReader, tracePoint: TRMethodCallTracePoint): TRTracePoint {
        if (tracePoint.events.size != 1) return tracePoint
        val singleChild = loadChildAndRestorePosition(reader, tracePoint = tracePoint, 0)
        if (singleChild == null) return tracePoint

        return tracePoint
            .compressDefaultPairs(singleChild)
            .compressAccessPairs(singleChild)
        // TODO: add more applicable
    }

    private fun loadChildAndRestorePosition(reader: LazyTraceReader, tracePoint: TRMethodCallTracePoint, index: Int): TRTracePoint? {
        val oldPosition = reader.data.position()
        reader.loadChild(tracePoint, index)
        reader.data.seek(oldPosition)
        return tracePoint.events[index]
    }
}


/**
 * Compresses `fun$default(...)` calls.
 *
 * Kotlin functions with default values are represented as two nested calls in the stack trace.
 *
 * For example:
 *
 * ```
 * A.callMe$default(A#1, 3, null, 2, null) at A.operation(A.kt:23)
 *   A.callMe(3, "Hey") at A.callMe$default(A.kt:27)
 * ```
 *
 * will be collapsed into:
 *
 * ```
 * A.callMe(3, "Hey") at A.operation(A.kt:23)
 * ```
 *
 */
private fun TRMethodCallTracePoint.compressDefaultPairs(singleChild: TRTracePoint): TRMethodCallTracePoint {
    if (singleChild !is TRMethodCallTracePoint) return this
    if (!haveSameOwner(className, singleChild.className) || !isDefaultPair(methodName, singleChild.methodName)) return this
    return combineCallNodes(this, singleChild)
}

/**
 * Compresses `.access$` calls.
 *
 * The `.access$` methods are generated by the Kotlin compiler to access otherwise inaccessible members
 * (e.g., private) from lambdas, inner classes, etc.
 *
 * For example:
 *
 * ```
 * A.access$callMe() at A.operation(A.kt:N)
 *  A.callMe() at A.access$callMe(A.kt:N)
 * ```
 *
 * will be collapsed into:
 *
 * ```
 * A.callMe() at A.operation(A.kt:N)
 * ```
 *
 */
private fun TRMethodCallTracePoint.compressAccessPairs(singleChild: TRTracePoint): TRMethodCallTracePoint {
    if (singleChild !is TRMethodCallTracePoint) return this
    if (!haveSameOwner(className, singleChild.className) || !isAccessPair(methodName, singleChild.methodName)) return this
    return combineCallNodes(this, singleChild)
}

private fun combineCallNodes(parent: TRMethodCallTracePoint, child: TRMethodCallTracePoint): TRMethodCallTracePoint {
    val newNode = TRMethodCallTracePoint(
        child.threadId,
        parent.codeLocationId,
        child.methodId,
        child.obj,
        child.parameters,
        child.eventId
    )
    newNode.result = child.result
    newNode.exceptionClassName = child.exceptionClassName
    newNode.replaceChildren(child)
    return newNode
}