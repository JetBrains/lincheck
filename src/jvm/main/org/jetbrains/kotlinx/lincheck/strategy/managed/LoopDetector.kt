/*
 * Lincheck
 *
 * Copyright (C) 2019 - 2024 JetBrains s.r.o.
 *
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed
 * with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

package org.jetbrains.kotlinx.lincheck.strategy.managed

import org.jetbrains.kotlinx.lincheck.strategy.managed.LoopDetectorDecision.*
import java.util.ArrayList

/**
 * The LoopDetector class identifies loops, active locks, and live locks by monitoring the frequency of visits to the same code location.
 * It operates under a specific scenario constraint due to its reliance on cache information about loops,
 * determined by thread executions and switches, which is only reusable in a single scenario.
 *
 * The LoopDetector functions in two modes: default and replay mode.
 *
 * In default mode:
 * - The LoopDetector tracks code location executions (using [currentThreadCodeLocationsHistory]) performed by threads.
 * The history is stored for the current thread and is cleared during a thread switch.
 * - A map ([currentThreadCodeLocationVisitCountMap]) is maintained to track the number of times a thread visits a certain code location.
 * This map is also cleared during a thread switch.
 * - If a code location is visited more than a defined [hangingDetectionThreshold], it is considered as a spin cycle.
 * The LoopDetector then tries to identify the sequence of actions leading to the spin cycle.
 * Once identified, this sub-interleaving is stored for future avoidance.
 * - A history of executions and switches is maintained to record the sequence of actions and thread switches.
 * - A [loopTrackingCursor] tracks executions and thread switches to facilitate early thread switches.
 * - A counter for operation execution [totalExecutionsCount] across all threads is maintained.
 * This counter increments with each code location visit and is increased by the hangingDetectionThreshold if a spin cycle is detected early.
 * - If the counter exceeds the [ManagedCTestConfiguration.LIVELOCK_EVENTS_THRESHOLD], a total deadlock is assumed.
 * Due to the relative small size of scenarios generated by Lincheck, such a high number of executions indicates a lack of progress in the system.
 *
 * In replay mode:
 * - The number of allowable events to execute in each thread is determined using saved information from the last interleaving.
 * - For instance, if the [currentInterleavingHistory] is [0: 2], [1: 3], [0: 3], [1: 3], [0: 3], ..., [1: 3], [0: 3] and a deadlock is detected,
 * the cycle is identified as [1: 3], [0: 3].
 * This means 2 executions in thread 0 and 3 executions in both threads 1 and 0 will be allowed.
 * - Execution is halted after the last execution in thread 0 using [ForcibleExecutionFinishError].
 * - The logic for tracking executions and switches in replay mode is implemented in [ReplayModeLoopDetectorHelper].
 *
 * Note: An example of this behavior is detailed in the comments of the code itself.
 */
internal class LoopDetector(
    private val nThreads: Int,
    private val hangingDetectionThreshold: Int
) {
    private var lastExecutedThread = -1// no last thread

    /**
     * Map, which helps us to determine how many times current thread visits some code location.
     */
    private val currentThreadCodeLocationVisitCountMap = mutableMapOf<Int, Int>()

    /**
     * Is used to find a cycle period inside exact thread execution if it has hung
     */
    private val currentThreadCodeLocationsHistory = mutableListOf<Int>()

    /**
     *  Threads switches and executions history to store sequences lead to loops
     */
    private val currentInterleavingHistory = ArrayList<InterleavingHistoryNode>()

    /**
     * When we're back to some thread, newSwitchPoint won't be called before the first event in the current
     * thread part as it was called before the switch. So when we return to a thread that already was running,
     * we have to start from 1 its executions counter. This set helps us to determine if some thread is running
     * for the first time in an execution or not.
     */
    private val threadsRan: BooleanArray = BooleanArray(nThreads) { false }

    /**
     * Set of interleaving event sequences lead to loops. (A set of previously detected hangs)
     */
    private val interleavingsLeadToSpinLockSet = InterleavingSequenceTrackableSet()

    /**
     * Helps to determine does current interleaving equal to some saved interleaving leading to spin cycle or not
     */
    private val loopTrackingCursor = interleavingsLeadToSpinLockSet.cursor

    private var totalExecutionsCount = 0

    private val firstThreadSet: Boolean get() = lastExecutedThread != -1

    /**
     * Delegate helper, active in replay (trace collection) mode.
     * It just tracks executions and switches and helps to halt execution or switch in case of spin-lock early.
     */
    private var replayModeLoopDetectorHelper: ReplayModeLoopDetectorHelper? = null

    val replayModeCurrentCyclePeriod: Int get() = replayModeLoopDetectorHelper?.currentCyclePeriod ?: 0

    val replayModeEnabled: Boolean get() = replayModeLoopDetectorHelper != null

    fun enableReplayMode(failDueToDeadlockInTheEnd: Boolean, traceCollector: ManagedStrategy.TraceCollector) {
        val contextSwitchesBeforeHalt =
            findMaxPrefixLengthWithNoCycleOnSuffix(currentInterleavingHistory)?.let { it.executionsBeforeCycle + it.cyclePeriod }
                ?: currentInterleavingHistory.size
        val spinCycleInterleavingHistory = currentInterleavingHistory.take(contextSwitchesBeforeHalt)
        // Remove references to interleaving tree
        interleavingsLeadToSpinLockSet.clear()
        loopTrackingCursor.clear()

        replayModeLoopDetectorHelper = ReplayModeLoopDetectorHelper(
            traceCollector = traceCollector,
            interleavingHistory = spinCycleInterleavingHistory,
            failDueToDeadlockInTheEnd = failDueToDeadlockInTheEnd
        )
    }

    fun shouldSwitchInReplayMode(): Boolean {
        return replayModeLoopDetectorHelper!!.run {
            onNextExecution()
            shouldSwitch()
        }
    }

    /**
     * Returns `true` if a loop or a hang is detected, `false` otherwise.
     */
    fun visitCodeLocation(iThread: Int, codeLocation: Int): LoopDetectorDecision {
        threadsRan[iThread] = true
        replayModeLoopDetectorHelper?.let {
            if (!it.shouldSwitch()) return IDLE
            return when (val activeLockNode = it.isActiveLockNode(iThread)) {
                is NeedToFailDueToDeadlock -> LIVELOCK_FAILURE_DETECTED
                is NormalReplayModeHelperResult -> if (it.shouldSwitch() && activeLockNode.isActiveLockNode) return LIVELOCK_THREAD_SWITCH else IDLE
            }
        }
        // Increase the total number of happened operations for live-lock detection
        totalExecutionsCount++
        // Have the thread changed? Reset the counters in this case.
        check(lastExecutedThread == iThread) { "reset expected!" }
        // Ignore coroutine suspension code locations.
        if (codeLocation == COROUTINE_SUSPENSION_CODE_LOCATION) return IDLE
        // Increment the number of times the specified code location is visited.
        val count = currentThreadCodeLocationVisitCountMap.getOrDefault(codeLocation, 0) + 1
        currentThreadCodeLocationVisitCountMap[codeLocation] = count
        currentThreadCodeLocationsHistory += codeLocation
        val detectedFirstTime = count > hangingDetectionThreshold
        val detectedEarly = loopTrackingCursor.isInCycle
        // DetectedFirstTime and detectedEarly can both sometimes be true
        // when we can't find a cycle period and can't switch to another thread.
        // Check whether the count exceeds the maximum number of repetitions for loop/hang detection.
        if (detectedFirstTime && !detectedEarly) {
            registerCycle()
            // Enormous operations count considered as total spin lock
            if (totalExecutionsCount > ManagedCTestConfiguration.LIVELOCK_EVENTS_THRESHOLD) {
                return EVENTS_THRESHOLD_REACHED
            }
            // Replay current interleaving to avoid side effects caused by multiple cycle executions
            return LIVELOCK_REPLAY_REQUIRED
        }
        if (!detectedFirstTime && detectedEarly) {
            totalExecutionsCount += hangingDetectionThreshold
            val lastNode = currentInterleavingHistory.last()
            // spinCyclePeriod may be not 0 only we tried to switch
            // from the current thread but no available threads were available to switch
            if (lastNode.spinCyclePeriod == 0) {
                // transform current node to the state corresponding to early found cycle
                val cyclePeriod = loopTrackingCursor.cyclePeriod
                lastNode.executions -= cyclePeriod
                lastNode.spinCyclePeriod = cyclePeriod
                lastNode.executionHash = loopTrackingCursor.cycleLocationsHash
            }
            // Enormous operations count considered as total spin lock
            if (totalExecutionsCount > ManagedCTestConfiguration.LIVELOCK_EVENTS_THRESHOLD) {
//                failDueToDeadlock()
                return EVENTS_THRESHOLD_REACHED
            }
        }
        return if (detectedFirstTime || detectedEarly) LIVELOCK_THREAD_SWITCH else IDLE
    }

    fun onActorStart(iThread: Int) {
        check(iThread == lastExecutedThread)
        // if a thread has reached a new actor, then it means it has made some progress;
        // therefore, we reset the code location counters,
        // so that code location hits from a previous actor do not affect subsequent actors
        currentThreadCodeLocationVisitCountMap.clear()
    }

    fun onThreadSwitch(iThread: Int) {
        lastExecutedThread = iThread
        currentThreadCodeLocationVisitCountMap.clear()
        currentThreadCodeLocationsHistory.clear()
        onNextThreadSwitchPoint(iThread)
    }

    fun onThreadFinish(iThread: Int) {
        check(iThread == lastExecutedThread)
        onNextExecutionPoint(executionIdentity = -iThread)
    }

    private fun onNextThreadSwitchPoint(nextThread: Int) {
        /*
            When we're back to some thread, newSwitchPoint won't be called before the fist
            in current thread part as it was called before switch.
            So, we're tracking that to maintain the number of performed operations correctly.
         */
        val threadRunningFirstTime = !threadsRan[nextThread]
        if (currentInterleavingHistory.isNotEmpty() && currentInterleavingHistory.last().threadId == nextThread) {
            return
        }
        currentInterleavingHistory.add(
            InterleavingHistoryNode(
                threadId = nextThread,
                executions = if (threadRunningFirstTime) 0 else 1,
            )
        )
        loopTrackingCursor.onNextSwitchPoint(nextThread)
        if (!threadRunningFirstTime) {
            loopTrackingCursor.onNextExecutionPoint()
        }
        replayModeLoopDetectorHelper?.onNextSwitch(threadRunningFirstTime)
    }

    /**
     * Is called after switch back to a thread
     */
    fun initializeFirstCodeLocationAfterSwitch(codeLocation: Int) {
        val lastInterleavingHistoryNode = currentInterleavingHistory.last()
        lastInterleavingHistoryNode.executionHash = lastInterleavingHistoryNode.executionHash xor codeLocation
    }

    fun onNextExecutionPoint(executionIdentity: Int) {
        val lastInterleavingHistoryNode = currentInterleavingHistory.last()
        if (lastInterleavingHistoryNode.cycleOccurred) {
            return /* If we already ran into cycle and haven't switched than no need to track executions */
        }
        lastInterleavingHistoryNode.addExecution(executionIdentity)
        loopTrackingCursor.onNextExecutionPoint()
        replayModeLoopDetectorHelper?.onNextExecution()
    }

    private fun registerCycle() {
        val cycleInfo = findMaxPrefixLengthWithNoCycleOnSuffix(currentThreadCodeLocationsHistory)
        if (cycleInfo == null) {
            val lastNode = currentInterleavingHistory.last()
            val cycleStateLastNode = lastNode.asNodeCorrespondingToCycle(
                executionsBeforeCycle = currentThreadCodeLocationsHistory.size - 1,
                cyclePeriod = 0,
                cycleExecutionsHash = lastNode.executionHash // corresponds to a cycle
            )

            currentInterleavingHistory[currentInterleavingHistory.lastIndex] = cycleStateLastNode
            interleavingsLeadToSpinLockSet.addBranch(currentInterleavingHistory)
            return
        }
        /*
        For nodes, correspond to cycles we re-calculate hash using only code locations related to the cycle,
        because if we run into a DeadLock,
        it's enough to show events before the cycle and first cycle iteration in the current thread.
        For example,
        [threadId = 0, executions = 10],
        [threadId = 1, executions = 5], // 2 executions before cycle and then cycle of 3 executions begins
        [threadId = 0, executions = 3],
        [threadId = 1, executions = 3],
        [threadId = 0, executions = 3],
        ...
        [threadId = 1, executions = 3],
        [threadId = 0, executions = 3]

        In this situation, we have a spin cycle:[threadId = 1, executions = 3], [threadId = 0, executions = 3].
        We want to cut off events suffix to get:
        [threadId = 0, executions = 10],
        [threadId = 1, executions = 5], // 2 executions before cycle, and then cycle begins
        [threadId = 0, executions = 3],

        So we need to [threadId = 1, executions = 5] execution part to have a hash equals to next cycle nodes,
        because we will take only thread executions before cycle and the first cycle iteration.
         */
        var cycleExecutionLocationsHash = currentThreadCodeLocationsHistory[cycleInfo.executionsBeforeCycle]
        for (i in cycleInfo.executionsBeforeCycle + 1 until cycleInfo.executionsBeforeCycle + cycleInfo.cyclePeriod) {
            cycleExecutionLocationsHash = cycleExecutionLocationsHash xor currentThreadCodeLocationsHistory[i]
        }

        val cycleStateLastNode = currentInterleavingHistory.last().asNodeCorrespondingToCycle(
            executionsBeforeCycle = cycleInfo.executionsBeforeCycle,
            cyclePeriod = cycleInfo.cyclePeriod,
            cycleExecutionsHash = cycleExecutionLocationsHash // corresponds to a cycle
        )

        currentInterleavingHistory[currentInterleavingHistory.lastIndex] = cycleStateLastNode
        interleavingsLeadToSpinLockSet.addBranch(currentInterleavingHistory)
    }

    /**
     * Is called before each interleaving part processing
     */
    fun beforePart(nextThread: Int) {
        clearRanThreads()
        if (!firstThreadSet) {
            setFirstThread(nextThread)
        } else if (lastExecutedThread != nextThread) {
            onThreadSwitch(nextThread)
        }
    }

    /**
     * Is called before each interleaving processing
     */
    fun initialize() {
        lastExecutedThread = -1
        clearRanThreads()
    }

    private fun clearRanThreads() {
        for (i in 0 until nThreads) {
            threadsRan[i] = false
        }
    }

    private fun setFirstThread(iThread: Int) {
        lastExecutedThread = iThread // certain last thread
        currentThreadCodeLocationVisitCountMap.clear()
        currentThreadCodeLocationsHistory.clear()
        totalExecutionsCount = 0

        loopTrackingCursor.reset(iThread)
        currentInterleavingHistory.clear()
        currentInterleavingHistory.add(InterleavingHistoryNode(threadId = iThread))
        replayModeLoopDetectorHelper?.initialize()
    }

}

enum class LoopDetectorDecision {
    IDLE,
    LIVELOCK_THREAD_SWITCH,
    LIVELOCK_REPLAY_REQUIRED,
    LIVELOCK_FAILURE_DETECTED,
    EVENTS_THRESHOLD_REACHED,
}

fun LoopDetectorDecision.isLiveLockDetected() = when (this) {
    LIVELOCK_THREAD_SWITCH,
    LIVELOCK_REPLAY_REQUIRED,
    LIVELOCK_FAILURE_DETECTED -> true
    else -> false
}

sealed interface ReplayModeHelperResult
data object NeedToFailDueToDeadlock: ReplayModeHelperResult
data class NormalReplayModeHelperResult(val isActiveLockNode: Boolean): ReplayModeHelperResult

/**
 * Helper class to halt execution on replay (trace collection phase) and to switch thread early on spin-cycles
 */
private class ReplayModeLoopDetectorHelper(
    private val traceCollector: ManagedStrategy.TraceCollector,
    private val interleavingHistory: List<InterleavingHistoryNode>,
    /**
     * Should we fail with deadlock failure when all events in the current interleaving are completed
     */
    private val failDueToDeadlockInTheEnd: Boolean,
) {

    fun isActiveLockNode(currentThread: Int): ReplayModeHelperResult {
        if (currentInterleavingNodeIndex == interleavingHistory.lastIndex) {
            // Fail if we ran into cycle,
            // this cycle node is the last node in the replayed interleaving,
            // and we have to fail at the end of the execution
            if (failDueToDeadlockInTheEnd) {
                return failDueToDeadlock(currentThread)
            }
        }
        return NormalReplayModeHelperResult(interleavingHistory[currentInterleavingNodeIndex].spinCyclePeriod != 0)
    }

    /**
     * Cycle period if is occurred in during current thread switch or 0 if no spin-cycle happened
     */
    val currentCyclePeriod: Int get() = interleavingHistory[currentInterleavingNodeIndex].spinCyclePeriod

    private var currentInterleavingNodeIndex = 0

    private var executionsPerformedInCurrentThread = 0

    /**
     * A set of thread, executed at least once during this interleaving.
     *
     * We have to maintain this set to determine how to initialize
     * [executionsPerformedInCurrentThread] after thread switch.
     * When a thread is executed for the first time, [newSwitchPoint]
     * strategy method is called before the first switch point,
     * so number of executions in this thread should start with zero,
     * and it will be incremented after [onNextExecution] call.
     *
     * But when we return to a thread which has already executed its operations, [newSwitchPoint]
     * strategy method won't be called,
     * as we already considered this switch point before we switched from this thread earlier,
     * [onNextExecution] won't be called before the first execution,
     * so we have to start [executionsPerformedInCurrentThread] from 1.
     */
    private val threadsRan = hashSetOf<Int>()

    fun initialize() {
        currentInterleavingNodeIndex = 0
        executionsPerformedInCurrentThread = 0
        threadsRan.clear()
    }

    /**
     * Called before next execution in current thread.
     */
    fun onNextExecution() {
        executionsPerformedInCurrentThread++
    }

    /**
     * Called before next thread switch
     */
    fun onNextSwitch(threadRunningFirstTime: Boolean) {
        currentInterleavingNodeIndex++
        // See threadsRan field description to understand the following initialization logic
        executionsPerformedInCurrentThread = if (threadRunningFirstTime) 0 else 1
    }

    /**
     * Called to determine if we should switch.
     *
     * @return true if the switch is required, false otherwise.
     */
    fun shouldSwitch(): Boolean {
        require(currentInterleavingNodeIndex <= interleavingHistory.lastIndex) {
            "Internal error"
        }
        val historyNode = interleavingHistory[currentInterleavingNodeIndex]
        return (executionsPerformedInCurrentThread > historyNode.spinCyclePeriod + historyNode.executions)
    }

    private fun failDueToDeadlock(currentThread: Int): NeedToFailDueToDeadlock {
        val cyclePeriod = interleavingHistory[currentInterleavingNodeIndex].spinCyclePeriod
        if (cyclePeriod != 0) {
            traceCollector.newActiveLockDetected(currentThread, cyclePeriod)
        }
        return NeedToFailDueToDeadlock
    }
}
