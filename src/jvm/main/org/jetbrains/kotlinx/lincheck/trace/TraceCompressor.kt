/*
 * Lincheck
 *
 * Copyright (C) 2019 - 2025 JetBrains s.r.o.
 *
 * This Source Code Form is subject to the terms of the
 * Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed
 * with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

package org.jetbrains.kotlinx.lincheck.trace

import org.jetbrains.kotlinx.lincheck.util.AnalysisProfile


internal fun SingleThreadedTable<TraceNode>.compressTrace() = this
    .compressSyntheticFieldAccess()
    .compressSuspendImpl()
    .compressDefaultPairs()
    .compressAccessPairs()
    .compressUserThreadRun()
    .compressThreadStart()
    .removeCoroutinesCoreSuffix()

/**
 * Compresses `receive$suspendImpl` calls.
 * 
 * These calls are part of suspend fun internals, but are not part of user code.
 * This function removes the `$suspendImpl` call and moves all its children to the parent.
 */
private fun SingleThreadedTable<TraceNode>.compressSuspendImpl() = compressNodes { node ->
    val singleChild = if (node.children.size == 1) node.children[0] else return@compressNodes node
    if (node !is CallNode || singleChild !is CallNode) return@compressNodes node
    if ("${node.tracePoint.methodName}\$suspendImpl" != singleChild.tracePoint.methodName) return@compressNodes node

    val newNode = node.copy()
    // trace grandchildren to children, inherit correct stackTraceElement, decrement depth
    singleChild.children.forEach {
        if (it.tracePoint is CodeLocationTracePoint) {
            (it.tracePoint as CodeLocationTracePoint).codeLocation = singleChild.tracePoint.codeLocation
        }
        newNode.addChild(it)
    }
    newNode
}

/**
 * Compresses `fun$default(...)` calls.
 *
 * Kotlin functions with default values are represented as two nested calls in the stack trace.
 *
 * For example:
 *
 * ```
 * A.calLMe$default(A#1, 3, null, 2, null) at A.operation(A.kt:23)
 *   A.callMe(3, "Hey") at A.callMe$default(A.kt:27)
 * ```
 *
 * will be collapsed into:
 *
 * ```
 * A.callMe(3, "Hey") at A.operation(A.kt:23)
 * ```
 *
 */
private fun SingleThreadedTable<TraceNode>.compressDefaultPairs() = compressNodes { node ->
    val singleChild = if (node.children.size == 1) node.children[0] else return@compressNodes node
    if (node !is CallNode || singleChild !is CallNode) return@compressNodes node
    if (!haveSameOwner(node.tracePoint, singleChild.tracePoint) || !isDefaultPair(node.tracePoint.methodName, singleChild.tracePoint.methodName)) return@compressNodes node
    combineNodes(node, singleChild)
}

/**
 * Compresses `.access$` calls.
 *
 * The `.access$` methods are generated by the Kotlin compiler to access otherwise inaccessible members
 * (e.g., private) from lambdas, inner classes, etc.
 *
 * For example:
 *
 * ```
 * A.access$callMe() at A.operation(A.kt:N)
 *  A.callMe() at A.access$callMe(A.kt:N)
 * ```
 *
 * will be collapsed into:
 *
 * ```
 * A.callMe() at A.operation(A.kt:N)
 * ```
 *
 */
private fun SingleThreadedTable<TraceNode>.compressAccessPairs() = compressNodes { node ->
    val singleChild = if (node.children.size == 1) node.children[0] else return@compressNodes node
    if (node !is CallNode || singleChild !is CallNode) return@compressNodes node
    if (!haveSameOwner(node.tracePoint, singleChild.tracePoint) || !isAccessPair(node.tracePoint.methodName, singleChild.tracePoint.methodName)) return@compressNodes node
    combineNodes(node, singleChild)
}

/**
 * Combine trace node for `default` and `access` functions.
 * For more details check [isDefaultPair] and [isAccessPair].
 */
private fun combineNodes(parent: CallNode, child: CallNode): TraceNode {
    parent.tracePoint.methodName = child.tracePoint.methodName
    parent.tracePoint.parameters = child.tracePoint.parameters

    check(parent.tracePoint.returnedValue == child.tracePoint.returnedValue)
    check(parent.tracePoint.thrownException == child.tracePoint.thrownException)

    val newNode = parent.copy() 
    child.children.forEach { newNode.addChild(it) }
    return newNode
}

/**
 * Remove `access$get` and `access$set`, which is used when a lambda argument accesses a private field for example.
 * This is different from `fun$access`, which is addressed in [compressDefaultAndAccessPairs].
 */
private fun SingleThreadedTable<TraceNode>.compressSyntheticFieldAccess() = compressNodes { node ->
    val singleChild = if (node.children.size == 1) node.children[0] else return@compressNodes node
    if (node !is CallNode || singleChild !is EventNode) return@compressNodes node
    if (!isSyntheticFieldAccess(node.tracePoint.methodName)) return@compressNodes node

    val point = singleChild.tracePoint
    if (point is ReadTracePoint) point.codeLocation = node.tracePoint.codeLocation
    if (point is WriteTracePoint) point.codeLocation = node.tracePoint.codeLocation

    singleChild
}

private fun SingleThreadedTable<TraceNode>.removeCoroutinesCoreSuffix() = compressNodes { node ->
    if (node is CallNode && node.tracePoint.methodName.endsWith("\$kotlinx_coroutines_core")) {
        node.tracePoint.methodName = node.tracePoint.methodName.removeSuffix("\$kotlinx_coroutines_core")
    }
    
    if (node.tracePoint is CodeLocationTracePoint && (node.tracePoint as CodeLocationTracePoint).stackTraceElement.methodName.endsWith("\$kotlinx_coroutines_core")) {
        val oldStackTraceElement = (node.tracePoint as CodeLocationTracePoint).stackTraceElement
        val newStackTraceElement = StackTraceElement(
            oldStackTraceElement.className,
            oldStackTraceElement.methodName.removeSuffix("\$kotlinx_coroutines_core"),
            oldStackTraceElement.fileName,
            oldStackTraceElement.lineNumber,
        )
        (node.tracePoint as CodeLocationTracePoint).stackTraceElement = newStackTraceElement
    }
    
    node
}

/**
 * Removes the lambda invocation line at the beginning of a user-defined thread trace.
 */
private fun SingleThreadedTable<TraceNode>.compressUserThreadRun() = compressNodes { node ->
    if (node !is CallNode || !node.tracePoint.isThreadStart) return@compressNodes node
    val child = if (node.children.size == 1) node.children[0] else return@compressNodes node

    if (child !is CallNode) return@compressNodes node
    if (!isUserThreadStart(node.tracePoint, child.tracePoint)) return@compressNodes node

    val newNode = node.copy()
    node.children.getOrNull(0)?.children?.forEach {
        newNode.addChild(it)
    }
    newNode
}

/**
 * When `thread() { ... }` is called it is represented as
 * ```
 * thread creation line: Thread#2 at A.fun(location)
 *     Thread#2.start()
 * ```
 * this function gets rid of the second line.
 * But only if it has been created with `thread(start = true)`
 */
private fun SingleThreadedTable<TraceNode>.compressThreadStart() = compressNodes { node ->
    if (node !is CallNode || !node.tracePoint.isThreadCreation() ) return@compressNodes node
    val firstChild = if (node.children.size == 1) node.children[0] else return@compressNodes node
    val secondChild = if (firstChild.children.size == 1) firstChild.children[0] else return@compressNodes node
    if (secondChild !is EventNode || !secondChild.tracePoint.isThreadStart()) return@compressNodes node

    val newNode = node.copy()
    newNode.addChild(secondChild)
    newNode
}

internal fun SingleThreadedTable<TraceNode>.collapseLibraries(analysisProfile: AnalysisProfile) = compressNodes { node -> 
    // if should not be hidden
    if (node !is CallNode || !analysisProfile.shouldBeHidden(node)) return@compressNodes node
    
    // if cannot be hidden (due to switch point)
    if (node.containsDescendant { it is EventNode && it.tracePoint is SwitchEventTracePoint }) 
        return@compressNodes node
    
    val newNode = node.copy()
    findSubTreesToBeShown(node, analysisProfile).forEach {  newNode.addChild(it) }
    return@compressNodes newNode
}

/**
 * Finds descendants that should not be hidden.
 * But not descendants of descendants, aka the roots of all subtrees that should be shown in the trace.
 */
private fun findSubTreesToBeShown(node: TraceNode, analysisProfile: AnalysisProfile): List<TraceNode> {
    if (node !is CallNode) return emptyList()
    if (!analysisProfile.shouldBeHidden(node)) return listOf(node)
    return node.children.map { findSubTreesToBeShown(it, analysisProfile) }.flatten()
}

private fun SingleThreadedTable<TraceNode>.compressNodes(compressionRule: (TraceNode) -> TraceNode) = map {
    it.map { it.compress(compressionRule) }
}

private fun TraceNode.compress(compressionRule: (TraceNode) -> TraceNode): TraceNode {
    val compressedNode = compressionRule(this)
    val newNode = compressedNode.copy()
    compressedNode.children.forEach { newNode.addChild(it.compress(compressionRule)) }
    return newNode
}

/**
 * Used in [compressDefaultPairs] and [compressAccessPairs]
 */
private fun haveSameOwner(currentPoint: MethodCallTracePoint, nextPoint: MethodCallTracePoint): Boolean =
    currentPoint.className == nextPoint.className

/**
 * Used in [compressDefaultPairs]
 */
private fun isDefaultPair(currentName: String, nextName: String): Boolean =
    currentName == "${nextName}\$default"

/**
 * Used in [compressAccessPairs]
 */
private fun isAccessPair(currentName: String, nextName: String): Boolean =
    currentName == "access$${nextName}"

private fun isSyntheticFieldAccess(methodName: String): Boolean =
    methodName.contains("access\$get") || methodName.contains("access\$set")

/**
 * Used to remove the lambda invocation line at the beginning of
 * a user-defined thread trace.
 */
private fun isUserThreadStart(currentTracePoint: MethodCallTracePoint, nextTracePoint: MethodCallTracePoint): Boolean =
    currentTracePoint.isThreadStart
            && nextTracePoint.className == "kotlin.jvm.functions.Function0"
            && nextTracePoint.methodName == "invoke"

private fun AnalysisProfile.shouldBeHidden(callNode: CallNode): Boolean = 
    shouldBeHidden(callNode.tracePoint.className, callNode.tracePoint.methodName)
